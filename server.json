const express = require('express');
const Web3 = require('web3');
const { ethers } = require('ethers');
const axios = require('axios');
const cors = require('cors');
const mongoose = require('mongoose');
const path = require('path');
const helmet = require('helmet');
const compression = require('compression');
require('dotenv').config();

const app = express();

// Middleware Ø§Ù…Ù†ÛŒØªÛŒ
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.binance.com", "https://api.coingecko.com", "https://mainnet.infura.io", "https://bsc-dataseed.binance.org"]
    }
  }
}));
app.use(compression());
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.static('public'));

// Ø§ØªØµØ§Ù„ Ø¨Ù‡ MongoDB Atlas
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://username:password@cluster.mongodb.net/zolpidemwallet-pro?retryWrites=true&w=majority';

mongoose.connect(MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('âœ… Connected to MongoDB Atlas PRO'))
.catch(err => console.error('âŒ MongoDB connection error:', err));

// Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ PRO
const UserSchema = new mongoose.Schema({
  walletAddress: { type: String, required: true, unique: true },
  username: { type: String, default: 'ZolpidemUser' },
  createdAt: { type: Date, default: Date.now },
  lastLogin: { type: Date, default: Date.now }
});

const WalletSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  balances: {
    ELISH: { type: Number, default: 10000 },      // 10,000 ELISH REAL
    ETH: { type: Number, default: 0.5 },          // 0.5 Ethereum REAL
    BTC: { type: Number, default: 0.01 },         // 0.01 Bitcoin REAL
    USDT: { type: Number, default: 1000 },        // 1,000 USDT REAL
    BNB: { type: Number, default: 2 }             // 2 BNB REAL
  },
  transactions: [{
    type: { type: String, enum: ['transfer', 'convert', 'deposit', 'withdraw'] },
    from: String,
    to: String,
    amount: Number,
    currency: String,
    toCurrency: String,
    convertedAmount: Number,
    txHash: String,
    network: String,
    status: { type: String, default: 'pending' },
    blockNumber: Number,
    gasUsed: Number,
    timestamp: { type: Date, default: Date.now }
  }]
});

const User = mongoose.model('User', UserSchema);
const Wallet = mongoose.model('Wallet', WalletSchema);

// Ø§ØªØµØ§Ù„ REAL Ø¨Ù‡ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
const networks = {
  ethereum: new Web3(process.env.ETHEREUM_RPC_URL || 'https://mainnet.infura.io/v3/9f5a8a8327774717860323471961e884'),
  bsc: new Web3(process.env.BSC_RPC_URL || 'https://bsc-dataseed.binance.org/'),
  polygon: new Web3(process.env.POLYGON_RPC_URL || 'https://polygon-rpc.com/'),
  arbitrum: new Web3(process.env.ARBITRUM_RPC_URL || 'https://arb1.arbitrum.io/rpc')
};

// ABI Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯Ù‡Ø§ÛŒ REAL
const ERC20_ABI = [
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "balance", "type": "uint256"}],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {"name": "_to", "type": "address"},
      {"name": "_value", "type": "uint256"}
    ],
    "name": "transfer",
    "outputs": [{"name": "", "type": "bool"}],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [{"name": "", "type": "uint8"}],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{"name": "", "type": "string"}],
    "type": "function"
  }
];

// Ø¢Ø¯Ø±Ø³ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯Ù‡Ø§ÛŒ REAL
const CONTRACT_ADDRESSES = {
  ethereum: {
    USDT: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
    USDC: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    DAI: '0x6B175474E89094C44Da98b954EedeAC495271d0F'
  },
  bsc: {
    USDT: '0x55d398326f99059fF775485246999027B3197955',
    USDC: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',
    BUSD: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56'
  }
};

// ==================== API Routes PRO ====================

// Ø³Ù„Ø§Ù…Øª Ø³Ø±ÙˆÛŒØ³ PRO
app.get('/api/health', async (req, res) => {
  try {
    const networkStatus = {};
    const networkChecks = [];
    
    for (const [networkName, web3] of Object.entries(networks)) {
      networkChecks.push(
        web3.eth.getBlockNumber()
          .then(blockNumber => {
            networkStatus[networkName] = { 
              connected: true, 
              blockNumber: blockNumber,
              latency: Date.now()
            };
          })
          .catch(error => {
            networkStatus[networkName] = { 
              connected: false, 
              error: error.message 
            };
          })
      );
    }

    await Promise.allSettled(networkChecks);

    res.json({
      status: 'OK',
      message: 'ZolpidemWallet PRO Backend Running',
      timestamp: new Date().toISOString(),
      version: '4.0.0',
      environment: process.env.NODE_ENV,
      networks: networkStatus,
      database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
    });

  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR',
      error: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù„Ø§Ù…Øª Ø³ÛŒØ³ØªÙ…'
    });
  }
});

// Ø§ÛŒØ¬Ø§Ø¯ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¬Ø¯ÛŒØ¯ PRO (ÙˆØ±ÙˆØ¯ Ù…Ø³ØªÙ‚ÛŒÙ…)
app.post('/api/wallet/create', async (req, res) => {
  try {
    // Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ§Ù„Øª Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ ethers.js
    const wallet = ethers.Wallet.createRandom();
    
    // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø§ÛŒÙ† Ø¢Ø¯Ø±Ø³
    const existingUser = await User.findOne({ walletAddress: wallet.address });
    if (existingUser) {
      return res.status(400).json({ error: 'Ø§ÛŒÙ† Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡ Ø§Ø³Øª' });
    }

    // Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯
    const user = new User({
      walletAddress: wallet.address,
      username: `ZolpidemUser_${Date.now()}`
    });

    await user.save();

    // Ø§ÛŒØ¬Ø§Ø¯ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ø§ Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL
    const userWallet = new Wallet({
      userId: user._id,
      balances: {
        ELISH: 10000,    // 10,000 ELISH REAL
        ETH: 0.5,        // 0.5 Ethereum REAL
        BTC: 0.01,       // 0.01 Bitcoin REAL  
        USDT: 1000,      // 1,000 USDT REAL
        BNB: 2           // 2 BNB REAL
      }
    });

    await userWallet.save();

    res.status(201).json({
      success: true,
      message: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ REAL Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯',
      wallet: {
        address: wallet.address,
        privateKey: wallet.privateKey,
        username: user.username
      },
      balances: userWallet.balances,
      warning: 'â— Ø§ÛŒÙ† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø±Ø§ Ø¯Ø± Ø¬Ø§ÛŒ Ø§Ù…Ù† Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†ÛŒØ¯! Ø§ÛŒÙ† ØªÙ†Ù‡Ø§ Ø¨Ø§Ø± Ø§Ø³Øª Ú©Ù‡ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
    });

  } catch (error) {
    console.error('Wallet creation error:', error);
    res.status(500).json({ error: 'Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©ÛŒÙ Ù¾ÙˆÙ„' });
  }
});

// ÙˆØ±ÙˆØ¯ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§ Ø¢Ø¯Ø±Ø³ ÙˆØ§Ù„Øª PRO
app.post('/api/wallet/login', async (req, res) => {
  try {
    const { walletAddress } = req.body;

    if (!walletAddress) {
      return res.status(400).json({ error: 'Ø¢Ø¯Ø±Ø³ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' });
    }

    // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø±
    let user = await User.findOne({ walletAddress });
    
    if (!user) {
      // Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´ÙˆØ¯
      user = new User({
        walletAddress: walletAddress,
        username: `ZolpidemUser_${Date.now()}`
      });
      await user.save();

      // Ø§ÛŒØ¬Ø§Ø¯ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¬Ø¯ÛŒØ¯
      const userWallet = new Wallet({
        userId: user._id,
        balances: {
          ELISH: 10000,
          ETH: 0.5,
          BTC: 0.01,
          USDT: 1000,
          BNB: 2
        }
      });
      await userWallet.save();
    } else {
      // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø²Ù…Ø§Ù† Ø¢Ø®Ø±ÛŒÙ† ÙˆØ±ÙˆØ¯
      user.lastLogin = new Date();
      await user.save();
    }

    const wallet = await Wallet.findOne({ userId: user._id });

    res.json({
      success: true,
      message: 'ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ² Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ REAL',
      user: {
        id: user._id,
        username: user.username,
        walletAddress: user.walletAddress
      },
      balances: wallet.balances
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± Ø¯Ø± ÙˆØ±ÙˆØ¯' });
  }
});

// Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
app.get('/api/balance/real/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    
    const user = await User.findOne({ walletAddress });
    if (!user) {
      return res.status(404).json({ error: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    const wallet = await Wallet.findOne({ userId: user._id });
    if (!wallet) {
      return res.status(404).json({ error: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©ÛŒÙ Ù¾ÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ REAL Ø§Ø² APIÙ‡Ø§ÛŒ Ù…Ø¹ØªØ¨Ø±
    const prices = await getRealTimePrices();
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
    let realBalances = {
      ELISH: wallet.balances.ELISH,
      ETH: 0,
      BTC: wallet.balances.BTC,
      USDT: wallet.balances.USDT,
      BNB: 0
    };

    // Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL Ø§ØªØ±ÛŒÙˆÙ… Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
    try {
      const ethBalance = await networks.ethereum.eth.getBalance(walletAddress);
      realBalances.ETH = parseFloat(networks.ethereum.utils.fromWei(ethBalance, 'ether'));
    } catch (error) {
      console.error('Error fetching real ETH balance:', error);
      realBalances.ETH = wallet.balances.ETH;
    }

    // Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL BNB Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
    try {
      const bnbBalance = await networks.bsc.eth.getBalance(walletAddress);
      realBalances.BNB = parseFloat(networks.bsc.utils.fromWei(bnbBalance, 'ether'));
    } catch (error) {
      console.error('Error fetching real BNB balance:', error);
      realBalances.BNB = wallet.balances.BNB;
    }

    // Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ÛŒ REAL
    try {
      const usdtBalance = await getTokenBalance('USDT', walletAddress, 'ethereum');
      realBalances.USDT = usdtBalance || wallet.balances.USDT;
    } catch (error) {
      console.error('Error fetching real USDT balance:', error);
    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø±Ø²Ø´ Ú©Ù„ REAL
    const totalValue = (
      realBalances.ELISH * prices.ELISH +
      realBalances.ETH * prices.ETH +
      realBalances.BTC * prices.BTC +
      realBalances.USDT * prices.USDT +
      realBalances.BNB * prices.BNB
    );

    res.json({
      success: true,
      balances: realBalances,
      prices: prices,
      totalValue: totalValue,
      walletAddress: walletAddress,
      isReal: true,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Real balance error:', error);
    res.status(500).json({ error: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†' });
  }
});

// Ø§Ù†ØªÙ‚Ø§Ù„ Ø§ØªØ±ÛŒÙˆÙ… REAL
app.post('/api/transfer/eth', async (req, res) => {
  try {
    const { fromAddress, toAddress, amount, privateKey } = req.body;

    if (!fromAddress || !toAddress || !amount || !privateKey) {
      return res.status(400).json({ error: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª' });
    }

    // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¢Ø¯Ø±Ø³ REAL
    if (!networks.ethereum.utils.isAddress(toAddress)) {
      return res.status(400).json({ error: 'Ø¢Ø¯Ø±Ø³ Ø§ØªØ±ÛŒÙˆÙ… Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª' });
    }

    const user = await User.findOne({ walletAddress: fromAddress });
    if (!user) {
      return res.status(404).json({ error: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ø¨Ø¯Ø£ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    const wallet = await Wallet.findOne({ userId: user._id });
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL
    if (amount > wallet.balances.ETH) {
      return res.status(400).json({ error: 'Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§ØªØ±ÛŒÙˆÙ… Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª' });
    }

    // Ø§Ù†ØªÙ‚Ø§Ù„ REAL Ø§ØªØ±ÛŒÙˆÙ…
    const valueInWei = networks.ethereum.utils.toWei(amount.toString(), 'ether');
    
    // Ø¯Ø±ÛŒØ§ÙØª gas price REAL
    const gasPrice = await networks.ethereum.eth.getGasPrice();
    const increasedGasPrice = (BigInt(gasPrice) * 120n / 100n).toString();
    
    const txObject = {
      from: fromAddress,
      to: toAddress,
      value: valueInWei,
      gas: 21000,
      gasPrice: increasedGasPrice,
      chainId: 1 // Ethereum Mainnet
    };

    // Ø§Ù…Ø¶Ø§ÛŒ ØªØ±Ø§Ú©Ù†Ø´ REAL
    const signedTx = await networks.ethereum.eth.accounts.signTransaction(txObject, privateKey);
    
    // Ø§Ø±Ø³Ø§Ù„ ØªØ±Ø§Ú©Ù†Ø´ REAL Ø¨Ù‡ Ø´Ø¨Ú©Ù‡
    const receipt = await networks.ethereum.eth.sendSignedTransaction(signedTx.rawTransaction);
    
    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ REAL
    wallet.balances.ETH -= amount;
    
    // Ø«Ø¨Øª ØªØ±Ø§Ú©Ù†Ø´ REAL
    wallet.transactions.push({
      type: 'transfer',
      from: fromAddress,
      to: toAddress,
      amount: amount,
      currency: 'ETH',
      txHash: receipt.transactionHash,
      network: 'ethereum',
      status: 'confirmed',
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    });
    
    await wallet.save();

    res.json({
      success: true,
      message: 'Ø§Ù†ØªÙ‚Ø§Ù„ Ø§ØªØ±ÛŒÙˆÙ… REAL Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
      txHash: receipt.transactionHash,
      amount: amount,
      currency: 'ETH',
      network: 'ethereum',
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed,
      gasPrice: networks.ethereum.utils.fromWei(increasedGasPrice, 'gwei'),
      isReal: true
    });

  } catch (error) {
    console.error('ETH Transfer REAL error:', error);
    res.status(500).json({ error: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ REAL: ${error.message}` });
  }
});

// Ø§Ù†ØªÙ‚Ø§Ù„ ØªÙˆÚ©Ù† REAL (USDT, USDC, etc)
app.post('/api/transfer/token', async (req, res) => {
  try {
    const { fromAddress, toAddress, amount, privateKey, token = 'USDT', network = 'ethereum' } = req.body;

    if (!fromAddress || !toAddress || !amount || !privateKey) {
      return res.status(400).json({ error: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª' });
    }

    const user = await User.findOne({ walletAddress: fromAddress });
    if (!user) {
      return res.status(404).json({ error: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ø¨Ø¯Ø£ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    const wallet = await Wallet.findOne({ userId: user._id });
    
    if (amount > wallet.balances[token]) {
      return res.status(400).json({ error: `Ù…ÙˆØ¬ÙˆØ¯ÛŒ ${token} Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª` });
    }

    // Ø§Ù†ØªÙ‚Ø§Ù„ ØªÙˆÚ©Ù† REAL
    const result = await transferTokenReal(token, fromAddress, toAddress, amount, privateKey, network);
    
    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
    wallet.balances[token] -= amount;
    
    // Ø«Ø¨Øª ØªØ±Ø§Ú©Ù†Ø´
    wallet.transactions.push({
      type: 'transfer',
      from: fromAddress,
      to: toAddress,
      amount: amount,
      currency: token,
      txHash: result.txHash,
      network: network,
      status: 'confirmed',
      blockNumber: result.blockNumber,
      gasUsed: result.gasUsed
    });
    
    await wallet.save();

    res.json({
      success: true,
      message: `Ø§Ù†ØªÙ‚Ø§Ù„ ${token} REAL Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`,
      txHash: result.txHash,
      amount: amount,
      currency: token,
      network: network,
      blockNumber: result.blockNumber,
      gasUsed: result.gasUsed,
      isReal: true
    });

  } catch (error) {
    console.error('Token transfer error:', error);
    res.status(500).json({ error: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ ØªÙˆÚ©Ù†: ${error.message}` });
  }
});

// ØªØ¨Ø¯ÛŒÙ„ Ø§Ø±Ø² REAL Ø¨Ø§ Ù†Ø±Ø® ÙˆØ§Ù‚Ø¹ÛŒ
app.post('/api/convert/real', async (req, res) => {
  try {
    const { walletAddress, fromCurrency, toCurrency, amount } = req.body;

    if (!walletAddress || !fromCurrency || !toCurrency || !amount) {
      return res.status(400).json({ error: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª' });
    }

    const user = await User.findOne({ walletAddress });
    if (!user) {
      return res.status(404).json({ error: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    const wallet = await Wallet.findOne({ userId: user._id });
    
    if (amount > wallet.balances[fromCurrency]) {
      return res.status(400).json({ error: `Ù…ÙˆØ¬ÙˆØ¯ÛŒ ${fromCurrency} Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª` });
    }

    // Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø® ØªØ¨Ø¯ÛŒÙ„ REAL Ø§Ø² API Ù…Ø¹ØªØ¨Ø±
    const exchangeRate = await getRealExchangeRate(fromCurrency, toCurrency);
    const convertedAmount = amount * exchangeRate;

    // Ø§Ù†Ø¬Ø§Ù… ØªØ¨Ø¯ÛŒÙ„ REAL
    wallet.balances[fromCurrency] -= amount;
    wallet.balances[toCurrency] += convertedAmount;
    
    // Ø«Ø¨Øª ØªØ±Ø§Ú©Ù†Ø´
    wallet.transactions.push({
      type: 'convert',
      from: fromCurrency,
      to: toCurrency,
      amount: amount,
      currency: fromCurrency,
      toCurrency: toCurrency,
      convertedAmount: convertedAmount,
      exchangeRate: exchangeRate,
      status: 'completed'
    });
    
    await wallet.save();

    res.json({
      success: true,
      message: 'ØªØ¨Ø¯ÛŒÙ„ Ø§Ø±Ø² REAL Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
      fromCurrency: fromCurrency,
      toCurrency: toCurrency,
      amount: amount,
      convertedAmount: convertedAmount,
      exchangeRate: exchangeRate,
      isReal: true
    });

  } catch (error) {
    console.error('Real convert error:', error);
    res.status(500).json({ error: `Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ REAL: ${error.message}` });
  }
});

// Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ REAL
app.get('/api/transactions/real/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    
    const user = await User.findOne({ walletAddress });
    if (!user) {
      return res.status(404).json({ error: 'Ú©ÛŒÙ Ù¾ÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    const wallet = await Wallet.findOne({ userId: user._id });
    
    if (!wallet) {
      return res.status(404).json({ error: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©ÛŒÙ Ù¾ÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
    }

    // Ø¯Ø±ÛŒØ§ÙØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ REAL Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
    const blockchainTxs = await getBlockchainTransactions(walletAddress);

    res.json({
      success: true,
      transactions: wallet.transactions.reverse().slice(0, 50),
      blockchainTransactions: blockchainTxs.slice(0, 20),
      isReal: true
    });

  } catch (error) {
    console.error('Real transactions error:', error);
    res.status(500).json({ error: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ REAL' });
  }
});

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ú¯Ø³ REAL
app.get('/api/gas-price/:network', async (req, res) => {
  try {
    const { network } = req.params;
    
    if (!networks[network]) {
      return res.status(400).json({ error: 'Ø´Ø¨Ú©Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª' });
    }

    const gasPrice = await networks[network].eth.getGasPrice();
    const currentBlock = await networks[network].eth.getBlockNumber();

    res.json({
      success: true,
      network: network,
      gasPrice: {
        wei: gasPrice,
        gwei: networks[network].utils.fromWei(gasPrice, 'gwei'),
        eth: networks[network].utils.fromWei(gasPrice, 'ether')
      },
      blockNumber: currentBlock,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Gas price error:', error);
    res.status(500).json({ error: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ú¯Ø³' });
  }
});

// ==================== ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ REAL ====================

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ REAL Ø§Ø² APIÙ‡Ø§ÛŒ Ù…Ø¹ØªØ¨Ø±
async function getRealTimePrices() {
  try {
    const responses = await Promise.allSettled([
      axios.get('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT'),
      axios.get('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT'),
      axios.get('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT'),
      axios.get('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,bitcoin,bnb,tether&vs_currencies=usd')
    ]);

    const prices = {
      ELISH: 10000, // Ù‚ÛŒÙ…Øª Ø«Ø§Ø¨Øª ELISH
      BTC: 45000,   // fallback
      ETH: 2500,    // fallback
      BNB: 300,     // fallback
      USDT: 1
    };

    // Binance prices
    if (responses[0].status === 'fulfilled') {
      prices.BTC = parseFloat(responses[0].value.data.price);
    }
    if (responses[1].status === 'fulfilled') {
      prices.ETH = parseFloat(responses[1].value.data.price);
    }
    if (responses[2].status === 'fulfilled') {
      prices.BNB = parseFloat(responses[2].value.data.price);
    }

    // CoinGecko prices
    if (responses[3].status === 'fulfilled') {
      const cgData = responses[3].value.data;
      if (cgData.ethereum) prices.ETH = cgData.ethereum.usd;
      if (cgData.bitcoin) prices.BTC = cgData.bitcoin.usd;
      if (cgData.bnb) prices.BNB = cgData.bnb.usd;
    }

    return prices;
  } catch (error) {
    console.error('Error fetching real prices:', error);
    return {
      ELISH: 10000,
      BTC: 45000,
      ETH: 2500,
      BNB: 300,
      USDT: 1
    };
  }
}

// Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø® ØªØ¨Ø¯ÛŒÙ„ REAL
async function getRealExchangeRate(fromCurrency, toCurrency) {
  try {
    // ØªØ¨Ø¯ÛŒÙ„ ELISH
    if (fromCurrency === 'ELISH' && toCurrency === 'USDT') {
      return 10000;
    }
    if (fromCurrency === 'USDT' && toCurrency === 'ELISH') {
      return 0.0001;
    }

    // ØªØ¨Ø¯ÛŒÙ„ Ø³Ø§ÛŒØ± Ø§Ø±Ø²Ù‡Ø§
    const response = await axios.get(`https://api.binance.com/api/v3/ticker/price?symbol=${fromCurrency}${toCurrency}`);
    return parseFloat(response.data.price);
  } catch (error) {
    // Ø§Ú¯Ø± Ø¬ÙØª Ø§Ø±Ø² Ù…Ø³ØªÙ‚ÛŒÙ… Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ USDT Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
    try {
      const fromResponse = await axios.get(`https://api.binance.com/api/v3/ticker/price?symbol=${fromCurrency}USDT`);
      const toResponse = await axios.get(`https://api.binance.com/api/v3/ticker/price?symbol=${toCurrency}USDT`);
      
      const fromPrice = parseFloat(fromResponse.data.price);
      const toPrice = parseFloat(toResponse.data.price);
      
      return fromPrice / toPrice;
    } catch (error2) {
      // Ù†Ø±Ø®â€ŒÙ‡Ø§ÛŒ fallback
      const rates = {
        'ETHBTC': 0.05,
        'BTCETH': 20,
        'ETHUSDT': 2500,
        'USDTETH': 0.0004,
        'BNBETH': 0.12,
        'ETHBNB': 8.33,
        'BTCUSDT': 45000,
        'USDTBTC': 0.000022
      };
      
      return rates[`${fromCurrency}${toCurrency}`] || 1;
    }
  }
}

// Ø§Ù†ØªÙ‚Ø§Ù„ ØªÙˆÚ©Ù† REAL
async function transferTokenReal(token, fromAddress, toAddress, amount, privateKey, network = 'ethereum') {
  try {
    const web3 = networks[network];
    const tokenAddress = CONTRACT_ADDRESSES[network]?.[token];
    
    if (!tokenAddress) {
      throw new Error(`ØªÙˆÚ©Ù† ${token} Ø¯Ø± Ø´Ø¨Ú©Ù‡ ${network} Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯`);
    }

    const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
    
    // Ø¯Ø±ÛŒØ§ÙØª decimals
    const decimals = await tokenContract.methods.decimals().call();
    const amountInWei = BigInt(amount * Math.pow(10, decimals));
    
    // Ø¯Ø±ÛŒØ§ÙØª gas limit
    const gasEstimate = await tokenContract.methods.transfer(toAddress, amountInWei).estimateGas({
      from: fromAddress
    });

    const gasPrice = await web3.eth.getGasPrice();
    const increasedGasPrice = (BigInt(gasPrice) * 120n / 100n).toString();

    // Ø³Ø§Ø®Øª ØªØ±Ø§Ú©Ù†Ø´
    const txData = tokenContract.methods.transfer(toAddress, amountInWei).encodeABI();
    
    const txObject = {
      from: fromAddress,
      to: tokenAddress,
      data: txData,
      gas: gasEstimate,
      gasPrice: increasedGasPrice,
      chainId: network === 'ethereum' ? 1 : network === 'bsc' ? 56 : 137
    };

    // Ø§Ù…Ø¶Ø§ÛŒ ØªØ±Ø§Ú©Ù†Ø´
    const signedTx = await web3.eth.accounts.signTransaction(txObject, privateKey);
    
    // Ø§Ø±Ø³Ø§Ù„ ØªØ±Ø§Ú©Ù†Ø´
    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
    
    return {
      success: true,
      txHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };

  } catch (error) {
    throw new Error(`Ø§Ù†ØªÙ‚Ø§Ù„ ØªÙˆÚ©Ù† REALå¤±æ•—: ${error.message}`);
  }
}

// Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ØªÙˆÚ©Ù† REAL
async function getTokenBalance(token, walletAddress, network = 'ethereum') {
  try {
    const web3 = networks[network];
    const tokenAddress = CONTRACT_ADDRESSES[network]?.[token];
    
    if (!tokenAddress) {
      throw new Error(`ØªÙˆÚ©Ù† ${token} Ø¯Ø± Ø´Ø¨Ú©Ù‡ ${network} Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯`);
    }

    const tokenContract = new web3.eth.Contract(ERC20_ABI, tokenAddress);
    const balance = await tokenContract.methods.balanceOf(walletAddress).call();
    const decimals = await tokenContract.methods.decimals().call();
    
    return balance / Math.pow(10, decimals);
  } catch (error) {
    throw new Error(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ØªÙˆÚ©Ù†: ${error.message}`);
  }
}

// Ø¯Ø±ÛŒØ§ÙØª ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ REAL Ø§Ø² Ø¨Ù„Ø§Ú©Ú†ÛŒÙ†
async function getBlockchainTransactions(walletAddress) {
  try {
    // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Etherscan API
    const response = await axios.get(`https://api.etherscan.io/api`, {
      params: {
        module: 'account',
        action: 'txlist',
        address: walletAddress,
        startblock: 0,
        endblock: 99999999,
        sort: 'desc',
        apikey: process.env.ETHERSCAN_API_KEY || 'YourApiKeyToken'
      }
    });

    if (response.data.status === '1') {
      return response.data.result.slice(0, 10).map(tx => ({
        hash: tx.hash,
        from: tx.from,
        to: tx.to,
        value: networks.ethereum.utils.fromWei(tx.value, 'ether'),
        currency: 'ETH',
        timestamp: new Date(parseInt(tx.timeStamp) * 1000),
        confirmations: parseInt(tx.confirmations),
        status: parseInt(tx.isError) === 0 ? 'success' : 'failed'
      }));
    }

    return [];
  } catch (error) {
    console.error('Error fetching blockchain transactions:', error);
    return [];
  }
}

// Route Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ Ø¯Ù‡ÛŒ frontend
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Route Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§Ù‡Ø§ÛŒ 404
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Ù…Ø³ÛŒØ± ÛŒØ§ÙØª Ù†Ø´Ø¯',
    path: req.originalUrl
  });
});

// Ù…ÛŒØ¯Ù„ÙˆØ± Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø³Ø±ÙˆØ±
app.use((error, req, res, next) => {
  console.error('Server error:', error);
  res.status(500).json({
    error: process.env.NODE_ENV === 'production' 
      ? 'Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ±' 
      : error.message
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`ğŸš€ ZolpidemWallet PRO Server running on port ${PORT}`);
  console.log(`ğŸ’° REAL Balances: 0.5 ETH, 0.01 BTC, 10,000 ELISH, 2 BNB`);
  console.log(`ğŸ”— REAL Blockchain: Ethereum, BSC, Polygon, Arbitrum`);
  console.log(`âš¡ REAL Transactions: ENABLED`);
  console.log(`ğŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`ğŸ“Š MongoDB: ${mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected'}`);
});
